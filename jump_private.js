const dimensions = [["o",0,0,0,40,560,[255,0,0]],["o",0,380,-100,20,20,[255,0,0]],["o",0,0,560,800,40,[255,0,0]],["o",0,760,0,40,560,[255,0,0]],["o",0,440,300,200,60,[255,0,0]],["o",0,640,300,20,60,[255,0,0]],["o",0,520,360,60,100,[255,0,0]],["o",0,520,460,60,100,[255,0,0]],["o",0,40,100,180,60,[255,0,0]],["s",0,1100,-20,20,20,[255,203,31]],["s",0,100,500,-60,60,[255,0,0]],["s",0,700,500,60,60,[255,0,0]],["o",1,0,0,40,600,[255,0,0]],["o",1,760,0,40,600,[255,0,0]],["o",1,520,0,60,240,[255,0,0]],["o",1,520,540,60,40,[255,0,0]],["o",1,180,420,100,20,[255,0,0]],["o",1,180,380,100,20,[255,0,0]],["o",1,220,400,20,20,[255,0,0]],["o",1,520,240,140,60,[255,0,0]],["o",1,520,480,140,60,[255,0,0]],["o",1,440,480,80,60,[255,0,0]],["o",1,40,60,220,20,[255,0,0]],["o",1,40,100,220,20,[255,0,0]],["o",1,100,80,20,20,[255,0,0]],["o",1,180,80,20,20,[255,0,0]],["o",1,440,240,40,60,[255,0,0]],["s",1,620,200,-40,40,[255,0,0]],["o",2,520,480,60,120,[219,129,20]],["o",2,760,0,40,600,[219,129,20]],["o",2,0,0,40,600,[219,129,20]],["o",2,460,480,60,20,[219,129,20]],["o",2,520,420,60,60,[219,129,20]],["o",2,700,560,60,40,[219,129,20]],["o",2,140,240,140,40,[219,129,20]],["o",2,100,280,220,20,[219,129,20]],["o",2,140,300,140,20,[219,129,20]],["o",2,180,320,60,20,[219,129,20]],["o",2,200,340,20,40,[219,129,20]],["o",2,520,240,60,20,[219,129,20]],["o",2,440,100,220,20,[219,129,20]],["o",2,480,60,140,40,[219,129,20]],["o",2,440,240,80,20,[219,129,20]],["o",2,580,240,80,20,[219,129,20]],["o",2,460,260,180,20,[219,129,20]],["o",2,500,280,100,20,[219,129,20]],["s",2,460,420,60,60,[219,129,20]],["s",2,320,240,-40,40,[219,129,20]],["s",2,100,240,40,40,[219,129,20]],["s",2,440,60,40,40,[219,129,20]],["s",2,660,60,-40,40,[219,129,20]],["o",3,760,0,40,600,[219,129,20]],["o",3,0,0,40,600,[219,129,20]],["o",3,200,520,100,20,[219,129,20]],["o",3,500,360,100,20,[219,129,20]],["o",3,600,360,40,180,[219,129,20]],["o",3,580,380,20,20,[219,129,20]],["o",3,580,400,20,20,[219,129,20]],["o",3,560,380,20,20,[219,129,20]],["o",3,500,240,100,20,[219,129,20]],["o",3,540,180,60,60,[219,129,20]],["o",3,600,140,40,120,[219,129,20]],["o",3,160,200,40,340,[219,129,20]],["o",3,200,200,20,40,[219,129,20]],["o",3,160,180,100,20,[219,129,20]],["s",3,500,200,40,40,[219,129,20]],["s",3,560,140,40,40,[219,129,20]],["o",4,0,0,40,600,[255,203,31]],["o",4,760,0,40,600,[255,203,31]],["o",4,660,100,20,120,[255,203,31]],["o",4,560,200,100,20,[255,203,31]],["o",4,680,100,80,20,[255,203,31]],["o",4,560,220,20,80,[255,203,31]],["o",4,460,300,120,20,[255,203,31]],["o",4,360,400,20,100,[255,203,31]],["o",4,380,400,80,20,[255,203,31]],["o",4,460,320,20,100,[255,203,31]],["o",4,560,320,20,180,[255,203,31]],["o",4,480,400,80,20,[255,203,31]],["o",4,660,220,20,280,[255,203,31]],["o",4,580,300,80,20,[255,203,31]],["o",4,680,300,80,20,[255,203,31]],["o",4,680,200,80,20,[255,203,31]],["o",4,580,400,80,20,[255,203,31]],["o",4,680,400,80,20,[255,203,31]],["o",4,460,420,20,80,[255,203,31]],["o",4,500,340,40,40,[255,203,31]],["o",4,600,240,40,40,[255,203,31]],["o",4,700,140,40,40,[255,203,31]],["o",4,700,240,40,40,[255,203,31]],["o",4,700,340,40,40,[255,203,31]],["o",4,600,340,40,40,[255,203,31]],["o",4,600,440,40,40,[255,203,31]],["o",4,400,440,40,40,[255,203,31]],["o",4,500,440,40,40,[255,203,31]],["o",4,700,440,40,40,[255,203,31]],["o",4,260,500,500,40,[255,203,31]],["o",4,40,500,80,40,[255,203,31]],["o",4,80,300,40,100,[255,203,31]],["o",4,400,140,40,40,[255,203,31]],["s",4,660,0,100,100,[255,203,31]],["s",4,560,100,100,100,[255,203,31]],["s",4,460,200,100,100,[255,203,31]],["s",4,360,300,100,100,[255,203,31]],["s",4,260,400,100,100,[255,203,31]],["o",5,0,0,40,600,[255,203,31]],["o",5,760,0,40,600,[255,203,31]],["o",5,40,520,200,40,[255,203,31]],["o",5,160,380,140,20,[255,203,31]],["o",5,160,260,20,120,[255,203,31]],["o",5,620,260,20,140,[255,203,31]],["o",5,500,380,120,20,[255,203,31]],["o",5,40,140,140,20,[255,203,31]],["o",5,380,240,40,20,[147,27,191]],["o",5,380,260,40,20,[147,27,191]],["o",5,340,280,120,20,[147,27,191]],["o",5,620,140,140,20,[255,203,31]],["o",5,560,520,200,40,[255,203,31]],["s",5,300,260,-120,120,[255,203,31]],["s",5,500,260,120,120,[255,203,31]],["s",5,180,0,-140,140,[255,203,31]],["s",5,340,240,40,40,[147,27,191]],["s",5,460,240,-40,40,[147,27,191]],["s",5,620,0,140,140,[255,203,31]],["o",6,0,0,40,600,[23,173,38]],["o",6,760,0,40,600,[23,173,38]],["o",6,180,520,20,20,[23,173,38]],["o",6,340,380,120,20,[23,173,38]],["o",6,340,360,20,20,[23,173,38]],["o",6,440,360,20,20,[23,173,38]],["o",6,600,220,20,20,[23,173,38]],["o",6,440,100,20,20,[23,173,38]],["o",6,340,100,20,20,[23,173,38]],["o",6,340,80,120,20,[23,173,38]],["o",6,100,540,100,20,[23,173,38]],["o",6,600,240,100,20,[23,173,38]],["o",7,760,540,40,60,[23,173,38]],["o",7,760,0,40,380,[23,173,38]],["o",7,780,380,20,160,[23,173,38]],["o",7,0,60,20,160,[23,173,38]],["o",7,0,0,40,60,[23,173,38]],["o",7,0,240,40,360,[23,173,38]],["o",7,720,540,40,20,[23,173,38]],["o",7,380,380,20,20,[23,173,38]],["o",7,400,380,20,20,[23,173,38]],["o",7,0,220,60,20,[23,173,38]],["o",8,760,0,40,600,[0,0,255]],["o",8,160,400,480,20,[0,0,255]],["o",8,240,200,20,60,[0,0,255]],["o",8,660,420,20,20,[0,0,255]],["o",8,640,400,20,20,[0,0,255]],["o",8,160,420,500,20,[0,0,255]],["o",8,0,0,40,280,[0,0,255]],["o",8,0,280,20,140,[0,0,255]],["o",8,0,420,40,180,[0,0,255]],["o",8,160,280,200,20,[0,0,255]],["o",8,180,260,180,20,[0,0,255]],["o",8,360,260,40,40,[0,0,255]],["o",8,400,260,20,40,[0,0,255]],["o",8,380,0,40,260,[0,0,255]],["o",8,240,0,20,120,[0,0,255]],["o",8,260,200,20,60,[0,0,255]],["o",8,260,0,20,120,[0,0,255]],["o",8,420,280,220,20,[0,0,255]],["o",8,660,520,20,20,[0,0,255]],["o",8,520,540,60,20,[0,0,255]],["o",8,540,560,20,20,[0,0,255]],["o",8,400,500,60,20,[0,0,255]],["o",8,420,520,20,20,[0,0,255]],["o",8,280,540,60,20,[0,0,255]],["o",8,300,560,20,20,[0,0,255]],["o",8,640,500,60,20,[0,0,255]],["s",8,160,260,20,20,[0,0,255]],["s",8,180,200,60,60,[0,0,255]],["s",8,680,400,-20,20,[0,0,255]],["s",8,640,60,-220,220,[0,0,255]],["o",9,240,520,40,80,[0,0,255]],["o",9,380,520,40,80,[0,0,255]],["o",9,760,0,40,600,[0,0,255]],["o",9,620,300,40,140,[0,0,255]],["o",9,620,40,40,140,[0,0,255]],["o",9,380,40,40,100,[0,0,255]],["o",9,380,240,40,140,[0,0,255]],["o",9,660,300,20,20,[0,0,255]],["o",9,620,440,40,80,[0,0,255]],["o",9,240,240,40,140,[0,0,255]],["o",9,280,260,20,20,[0,0,255]],["o",9,360,260,20,20,[0,0,255]],["o",9,240,40,40,100,[0,0,255]],["o",9,240,0,40,40,[0,0,255]],["o",9,380,0,40,40,[0,0,255]],["o",9,620,0,40,40,[0,0,255]],["o",9,0,240,40,360,[0,0,255]],["o",9,0,0,40,120,[0,0,255]],["o",9,0,120,20,120,[0,0,255]],["s",9,360,240,20,20,[0,0,255]],["s",9,300,240,-20,20,[0,0,255]],["o",10,240,560,40,40,[147,27,191]],["o",10,380,560,40,40,[147,27,191]],["o",10,620,560,40,40,[147,27,191]],["o",10,620,340,40,220,[147,27,191]],["o",10,240,260,180,40,[147,27,191]],["o",10,0,0,40,600,[147,27,191]],["o",10,760,0,40,600,[147,27,191]],["o",10,240,300,40,60,[147,27,191]],["o",10,360,220,20,40,[147,27,191]],["o",10,280,220,20,40,[147,27,191]],["o",10,240,520,40,40,[147,27,191]],["o",10,240,500,40,20,[147,27,191]],["o",10,660,240,20,120,[147,27,191]],["o",10,620,220,60,20,[147,27,191]],["o",10,620,160,40,60,[147,27,191]],["o",10,660,360,20,20,[147,27,191]],["o",10,380,300,40,120,[147,27,191]],["o",10,300,0,60,60,[147,27,191]],["o",10,260,80,40,20,[147,27,191]],["o",10,360,80,40,20,[147,27,191]],["o",10,300,60,60,20,[147,27,191]],["s",10,420,220,-40,40,[147,27,191]],["s",10,240,220,40,40,[147,27,191]],["s",10,680,200,-20,20,[147,27,191]],["s",10,260,40,40,40,[147,27,191]],["s",10,400,40,-40,40,[147,27,191]],["o",11,300,560,60,40,[147,27,191]],["o",11,0,0,40,600,[147,27,191]],["o",11,760,0,40,600,[147,27,191]],["o",11,240,240,20,40,[255,203,31]],["o",11,580,460,20,40,[255,203,31]],["o",12,0,0,40,600,[242,29,221]],["o",12,760,0,40,600,[242,29,221]],["o",12,40,0,720,40,[242,29,221]],["o",12,380,560,380,40,[242,29,221]],["o",12,40,560,100,40,[242,29,221]],["o",12,520,540,160,20,[94,59,12]],["o",12,560,520,60,20,[94,59,12]],["o",12,540,520,20,20,[94,59,12]],["o",12,620,520,20,20,[94,59,12]],["o",12,640,520,20,20,[94,59,12]],["o",12,600,500,60,20,[94,59,12]],["o",12,580,500,20,20,[94,59,12]],["o",12,600,480,40,20,[94,59,12]],["o",12,620,460,20,20,[94,59,12]]]

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

var devMode = false


var colorIndex = 0
var colors = [
    [255, 0, 0],
    [219, 129, 20],
    [255, 203, 31],
    [23, 173, 38],
    [0, 0, 255],
    [147, 27, 191],
    [242, 29, 221],
    [94, 59, 12],
]

var stringColors = []
for (let i = 0; i < colors.length; i++) {
    const color = colors[i]
    stringColors.push('rgba(' + color[0].toString() + ',' + color[1].toString() + ',' + color[2].toString() + ')')
}


function getTint(color, amount) {
    var tint = [...color]

    for (let i = 0; i < tint.length; i++) {
        if (tint[i] <= amount) {
            tint[i] += amount
        } else {
            tint[i] = 255
        }
    }

    return 'rgb(' + tint[0] + ',' + tint[1] + ',' + tint[2] + ')' 

} 

function getShade(color, amount) {
    var shade = [...color]

    for (let i = 0; i < shade.length; i++) {
        if (shade[i] >= amount) {
            shade[i] -= amount
        } else {
            shade[i] = 0
        }
    }

    return 'rgb(' + shade[0] + ',' + shade[1] + ',' + shade[2] + ')' 

} 

function listToString(list) {
    var string = '['
    for (let i = 0; i < list.length; i++) {
        const element = list[i]
        element.toString()
        string += element

        if (i != list.length - 1) {
            string += ','
        }
    }

    string += ']'
    return string
}

function listToString2(list) {
    var string = ''
    for (let i = 0; i < list.length; i++) {
        const element = list[i]
        element.toString()
        string += element

        if (i != list.length - 1) {
            string += ','
        }
    }

    return string
}


const keys = []

document.addEventListener('keydown', (event) => {
    const keyName = event.key.toLowerCase();
    console.log(keyName)

    if (devMode) {
        if (keyName == 'arrowdown' && areaIndex != 0) {
            areaIndex -= 1
        }
        
        if (keyName == 'arrowup' && areaIndex != areas.length - 1) {
            areaIndex += 1
        }
    }


    if (devMode) {
        if (keyName == 'e') {
        mode = Obstacle
        }

        if (keyName == 's') {
            mode = Slope
        }

        if (keyName == 'g') {
            grid = !grid
        }


        if (keyName == 'enter') {
            var dim = []

            for (let i = 0; i < areas.length; i++) {
                const ar = areas[i]
                for (let e = 0; e < ar.obstacles.length; e++) {
                    const ob = ar.obstacles[e]
                    dim.push(['o', ob.areaIndex, ob.x, ob.y, ob.width, ob.height, ob.rawColor])
                }
                for (let e = 0; e < ar.slopes.length; e++) {
                    const sl = ar.slopes[e]
                    dim.push(['s', sl.areaIndex, sl.x, sl.y - sl.height, sl.width, sl.height, sl.rawColor])
                }
            }

            console.log(dim)
        }
    }

    if (!keys.includes(keyName)) {
        keys.push(keyName);
    }


})


document.addEventListener('keyup', (event) => {
    const keyName = event.key.toLowerCase();

    if (keys.includes(keyName)) {
        const index = keys.indexOf(keyName);
        keys.splice(index, 1);
    }

    if (keyName == ' ') {
        // console.log('release')

        if (keys.includes('a') || keys.includes('arrowleft')) {
            var direction = -8
        } 
        else if (keys.includes('d') || keys.includes('arrowright')) {
            var direction = 8
        } else {
            var direction = 0
        }

        player.jump(direction)
    }

})



function getMousePos(canvas, evt) {
    var border = 0
    var rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left - border,
      y: evt.clientY - rect.top - border
    };
}


var obstacleStart = undefined

document.addEventListener('mousedown', (event) => {

    if (devMode) {
        if (event.which == 1) {
            let mouse = getMousePos(canvas, event)

            if (mouse.x < canvas.width && mouse.x > 0 && mouse.y < canvas.height && mouse.y > 0) {
                obstacleStart = pointToTile(mouse)
            }

        } else if (event.which == 5) {
            let mouse = getMousePos(canvas, event)
            player.y = mouse.y; player.x = mouse.x
            player.vx = 0; player.vy = 0
            player.airborn = true

        } else if (event.which == 3) {
            let point = pointToTile(getMousePos(canvas, event))
            let key = [point.x, point.y]
            let obstacle = areas[areaIndex].obstacleTiles[key]
            let slope = areas[areaIndex].slopeTiles[key]

            if (obstacle) {
                obstacle.delete()
                areas[areaIndex].updateShading()
            } else if (slope) {
                slope.delete()
                areas[areaIndex].updateShading()
            }
        }
    }
})


document.addEventListener('mouseup', (event) => {
    if (devMode) {
        if (event.which == 1) {
            let mouse = getMousePos(canvas, event)
            
            if (obstacleStart && mouse.x < canvas.width && mouse.x > 0 && mouse.y < canvas.height && mouse.y > 0) {
                var obstacleEnd = pointToTile(getMousePos(canvas, event))
                let width = obstacleEnd.x - obstacleStart.x + tileSize
                let height = obstacleEnd.y - obstacleStart.y + tileSize

                new mode(areaIndex, obstacleStart.x, obstacleStart.y, width, height, colors[colorIndex])
                obstacleStart = undefined
                areas[areaIndex].updateShading()
            }
        }
    }
})


document.addEventListener('wheel', (event) => {
    colorIndex += event.deltaY / Math.abs(event.deltaY)
    colorIndex %= colors.length
    if (colorIndex < 0) {colorIndex = colors.length - 1}
    console.log(colorIndex)
})


document.addEventListener('contextmenu', (event) => {
    var mouse_pos = getMousePos(canvas, event)
    
    if (0 < mouse_pos.x && mouse_pos.x < canvas.width) {
        if (0 < mouse_pos.y && mouse_pos.y < canvas.width) {
            event.preventDefault()
        }
    }
})



const tileSize = 20

function pointToTile(point) {
    return {'x': point.x - (point.x % tileSize), 'y': point.y - (point.y % tileSize)}
}




class Player {
    constructor(x, y) {
        this.x = x
        this.y = y
        this.width = 30
        this.height = 30

        this.charge = 0
        this.maxCharge = 40
        this.vy = 0
        this.vx = 0
        this.termVY = 40
        this.airborn = true
        this.slipping = false
        this.jumps = 1
    }

    chargeJump() {
        if (this.charge < this.maxCharge) {
            this.charge += 1.35
        } else {
            this.charge = this.maxCharge

            if (keys.includes('a') || keys.includes('arrowleft')) {
                var direction = -7.5
            } 
            else if (keys.includes('d') || keys.includes('arrowright')) {
                var direction = 7.5
            } else {
                var direction = 0
            }
    
            player.jump(direction)
        }
    }

    jump(direction) {
        if (this.jumps > 0) {
            this.jumps -= 1
            this.airborn = true
            this.vy = -this.charge / 1.6
            this.vx = direction
            this.charge = 0
        }
    }

    fall() {
        this.jumps = 0
        
        if (this.vy < this.termVY) {
            this.vy += 0.8
        } else {
            this.vy = this.termVY
        }

        if (this.airborn) {
            this.move(0, this.vy)
            this.move(this.vx, 0)
        }
    }

    land() {
        this.airborn = false
        this.slipping = false
        this.vy = 0
        this.vx = 0
        this.jumps = 1
    }

    move(xMove, yMove) {
        this.x += xMove
        this.y += yMove

        this.collide(areas[areaIndex].obstacles, areas[areaIndex].slopes, xMove, yMove)
    }

    collide(obstacles, slopes, xMove, yMove) {
        for (let i = 0; i < obstacles.length; i++) {
            const o = obstacles[i];
            if (this.x + this.width > o.x && this.x < o.x + o.width) {
                if (this.y + this.height > o.y && this.y < o.y + o.height) {

                    if (xMove > 0) {
                        this.x = o.x - this.width
                        this.vx *= -0.5

                    } else if (xMove < 0) {
                        this.x = o.x + o.width
                        this.vx *= -0.5
                    }

                    if (yMove > 0) {
                        this.y = o.y - this.height
                        this.land()

                    } else if (yMove < 0) {
                        this.y = o.y + o.height
                        this.vy = 0
                    }

                }
            }
        }

        for (let i = 0; i < slopes.length; i++) {
            const s = slopes[i];
            if (s.dir > 0) {
                if (this.x + this.width > s.x && this.x < s.x + s.width) {
                    if (this.y + this.height > s.y - s.height && this.y < s.y) {
                        let fx = (this.x + this.width - s.x) / s.width
                        let fy = 1 - ((this.y + this.height - s.y) / -s.height)
                        // console.log(fx, fy)

                        if ((fx + fy) > 1 && fx < 1.01 && fy < 1.01) {

                            if (!this.slipping) {
                                this.vx *= 0.5
                            }

                            this.vx -= 0.8
                            this.vy = 1
                            this.slipping = true
                            this.y = s.y - fx * s.height - this.height
                            this.airborn = true
                        }
                    }
                }

            } else if (s.dir < 0) {
                if (this.x + this.width > s.x + s.width && this.x < s.x) {
                    if (this.y + this.height > s.y - s.height && this.y < s.y) {
                        let fx = (this.x - s.x) / s.width
                        let fy = 1 - ((this.y + this.height - s.y) / -s.height)
                        // console.log(fx, fy)

                        if ((fx + fy) > 1 && fx < 1.01 && fy < 1.01) {

                            if (!this.slipping) {
                                this.vx *= 0.5
                            }

                            this.vx += 0.8
                            this.vy = 1
                            this.slipping = true
                            this.y = s.y - fx * s.height - this.height
                            this.airborn = true
                        }
                    }
                }
            }
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.fillStyle = 'white'

        if (this.charge > 0) {
            var height = this.height / 2
            var y = this.y + height
        } else {
            var height = this.height
            var y = this.y
        }

        ctx.fillRect(this.x, y, this.width, height);
        ctx.fillStyle = 'silver'
        ctx.fillRect(this.x, y + height - 5, this.width, 5)
        ctx.fillRect(this.x, y, 5, height)
    }
}



const areas = []
var areaIndex = 0

// const neighbors = [
//     [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]
// ]
const neighbors = [
    [1, 0], [0, 1], [-1, 0], [0, -1], [1, -1], [1, 1], [-1, 1], [-1, -1]
]

const tint = 'rgb(255, 96, 84)'
const shade = 'rgb(184, 33, 22)'

const borderWidth = 5
const shadingLegend = new Map([
    ['[1,0]', [false, tileSize - borderWidth, 0, borderWidth, tileSize, 'tint']],
    ['[0,1]', [false, 0, tileSize - borderWidth, tileSize, borderWidth, 'shade']],
    ['[-1,0]', [false, 0, 0, borderWidth, tileSize, 'shade']],
    ['[0,-1]', [false, 0, 0, tileSize, borderWidth, 'tint']],
    ['[1,-1]', [false, tileSize - borderWidth, 0, borderWidth, borderWidth, 'tint']],
    ['[1,1]', [false, tileSize - borderWidth, tileSize - borderWidth, borderWidth, borderWidth, 'shade']],
    ['[-1,1]', [false, 0, tileSize - borderWidth, borderWidth, borderWidth, 'shade']],
    ['[-1,-1]', [false, 0, 0, borderWidth, borderWidth, 'tint']]
])




class Area {
    constructor(number) {
        areas.push(this)
        this.number = number

        this.obstacles = []
        this.obstacleTiles = {}
        this.slopes = []
        this.slopeTiles = {}
        this.neighborMap = new Map()
    }

    updateShading() {
        this.neighborMap = new Map()
        
        for (const [key, value] of Object.entries(this.obstacleTiles)) {
            var stringTile = "[" + key + "]"
            var tile = JSON.parse("[" + key + "]")

            this.neighborMap.set(stringTile, [value.color, value.tint, value.shade])

            var count = 0
            for (let n = 0; n < neighbors.length; n++) {
                let nOffset = neighbors[n]

                let index = listToString2([tile[0] + nOffset[0] * tileSize, tile[1] + nOffset[1] * tileSize])

                if (nOffset.includes(0)) {
                    if (!Object.keys(this.obstacleTiles).includes(index) && !Object.keys(this.slopeTiles).includes(index)) {
                        this.neighborMap.get(stringTile).push(nOffset)
                        count += 1                    }
                } else {
                    // let adj1 = listToString2([tile[0] + nOffset[0] * tileSize, tile[1]])
                    // let adj2 = listToString2([tile[0], tile[1] + nOffset[1] * tileSize])

                    let adjacents = [
                        listToString2([tile[0] + nOffset[0] * tileSize, tile[1]]),
                        listToString2([tile[0], tile[1] + nOffset[1] * tileSize])
                    ]


                    if (!Object.keys(this.obstacleTiles).includes(index) && 
                        !Object.keys(this.slopeTiles).includes(index) && 
                        // adjacents.every(value => {Object.keys(this.obstacleTiles).includes(value)})) {
                        Object.keys(this.obstacleTiles).includes(adjacents[0]) &&
                        Object.keys(this.obstacleTiles).includes(adjacents[1])) {
                            this.neighborMap.get(stringTile).push(nOffset)
                        }
                }

            // console.log(stringTile, 'count ', count)
            // if (count == 0) {
                // console.log('delete')
            // }

            }
        }
    }

    drawShading(ctx) {
        for (const [key, value] of this.neighborMap.entries()) {
            var tile = JSON.parse(key)
            
            for (let i = 3; i < value.length; i++) {
                let index = listToString(value[i])
                const specs = shadingLegend.get(index)

                // console.log(index)
                if (specs[5] == 'tint') {var color = value[1]} else if (specs[5] == 'shade') {var color = value[2]}

                if (!specs[0])
                    ctx.fillStyle = color
                    ctx.fillRect(tile[0] + specs[1], tile[1] + specs[2], specs[3], specs[4]);

            }
        }

        // for (const [key, value] of Object.entries(this.obstacleTiles)) {
        //     // console.log(key)
        //     var tile = JSON.parse("[" + key + "]")

        //     ctx.fillStyle = 'blue'
        //     ctx.fillRect(tile[0], tile[1], tileSize, tileSize)
        // }
    }
}


class Obstacle {
    constructor(areaIndex, x, y, width, height, color) {
        
        this.x = x
        this.y = y
        
        // changing attributes if width or height input is negative
        var xAddend = 0; var yAddend = 0
        if (width <= 0) {this.x += width - tileSize; xAddend = tileSize * 2}
        if (height <= 0) {this.y += height - tileSize; yAddend = tileSize * 2}

        this.width = Math.abs(width) + xAddend
        this.height = Math.abs(height) + yAddend
        

        var toAdd = []
        for (let i = 0; i < this.width / tileSize; i++) {
            for (let e = 0; e < this.height / tileSize; e++) {
                let tile = [this.x + i * tileSize, this.y + e * tileSize]
                let strTile = listToString2(tile)

                // if new obstacle overlaps with existing ones, cancel
                if (Object.keys(areas[areaIndex].obstacleTiles).includes(strTile)) {
                    return
                } 

                toAdd.push(tile)
            }
        }

        for (let i = 0; i < toAdd.length; i++) {
            areas[areaIndex].obstacleTiles[toAdd[i]] = this
        }
        
        areas[areaIndex].obstacles.push(this)
        this.areaIndex = areaIndex

        this.rawColor = color
        this.color = 'rgba(' + color[0].toString() + ',' + color[1].toString() + ',' + color[2].toString() + ')'
        this.tint = getTint(color, 90)
        this.shade = getShade(color, 90)
    }

    delete() {
        areas[this.areaIndex].obstacles.splice(areas[this.areaIndex].obstacles.indexOf(this), 1)

        for (let i = 0; i < this.width / tileSize; i++) {
            for (let e = 0; e < this.height / tileSize; e++) {
                delete areas[areaIndex].obstacleTiles[[this.x + i * tileSize, this.y + e * tileSize]]
            }
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.fillStyle = this.color
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

class Slope {
    constructor(areaIndex, x, y, width, height, color) {
        areas[areaIndex].slopes.push(this)
        this.areaIndex = areaIndex

        this.dir = width / Math.abs(width)
        if (this.dir < 0) {var addend = -tileSize} else {var addend = 0}

        for (let i = 0; i < Math.abs(width) / tileSize; i++) {
            for (let e = height / tileSize - i - 1; e < height / tileSize; e++) {
                areas[areaIndex].slopeTiles[[x + i * tileSize * this.dir + addend, y + e * tileSize]] = this
            }
        }

        this.x = x
        this.y = y + height
        this.width = width
        this.height = height

        this.rawColor = color
        this.color = 'rgba(' + color[0].toString() + ',' + color[1].toString() + ',' + color[2].toString() + ')'
        this.tint = getTint(color, 90)
        this.shade = getShade(color, 90)
        
        this.points = [[x, this.y], [x + width, this.y], [x + width, this.y - height]]

        if (this.dir > 0) {this.lighting = this.shade} else {this.lighting = this.tint}
    }

    delete() {
        areas[this.areaIndex].slopes.splice(areas[this.areaIndex].slopes.indexOf(this), 1)

        if (this.dir < 0) {var addend = -tileSize} else {var addend = 0}

        for (let i = 0; i < Math.abs(this.width) / tileSize; i++) {
            for (let e = this.height / tileSize - i - 1; e < this.height / tileSize; e++) {
                delete areas[areaIndex].slopeTiles[[this.x + i * tileSize * this.dir + addend, 
                                                    this.y - this.height + e * tileSize]]
            }
        }
    }

    draw(ctx) {
        ctx.lineWidth = 0
        ctx.fillStyle = this.color
        ctx.beginPath()
        ctx.moveTo(this.points[0][0], this.points[0][1])
        ctx.lineTo(this.points[1][0], this.points[1][1])
        ctx.lineTo(this.points[2][0], this.points[2][1])
        ctx.lineTo(this.points[0][0], this.points[0][1])
        ctx.fill()
        
        ctx.lineWidth = borderWidth
        ctx.strokeStyle = this.lighting
        ctx.beginPath()
        ctx.moveTo(this.points[0][0], this.points[0][1])
        ctx.lineTo(this.points[2][0], this.points[2][1])
        ctx.stroke()

        // ctx.fillStyle = 'white'
        // ctx.beginPath();
        // ctx.arc(this.x, this.y, 3, 0, 2 * Math.PI);
        // ctx.fill();
    }
}




var mode = Obstacle
var grid = false

const player = new Player(100, 400)

for (let i = 0; i < 13; i++) {
    new Area(0)
}

for (let i = 0; i < dimensions.length; i++) {
    const array = dimensions[i]
    if (array[0] == 'o') {
        new Obstacle(array[1], array[2], array[3], array[4], array[5], array[6])
    } else if (array[0] == 's') {
        new Slope(array[1], array[2], array[3], array[4], array[5], array[6])
    }
    
}

for (let i = 0; i < areas.length; i++) {
    areas[i].updateShading()
}


function drawWindow() {
    var ctx = canvas.getContext('2d');

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    player.draw(ctx)

    for (let i = 0; i < areas[areaIndex].obstacles.length; i++) {
        areas[areaIndex].obstacles[i].draw(ctx)
    }

    for (let i = 0; i < areas[areaIndex].slopes.length; i++) {
        areas[areaIndex].slopes[i].draw(ctx)
    }

    areas[areaIndex].drawShading(ctx)

    if (grid) {
        ctx.strokeStyle = 'white'
        ctx.lineWidth = 1
        for (let w = 0; w < canvas.width / tileSize; w++) {
            ctx.beginPath()
            ctx.moveTo(w * tileSize, 0)
            ctx.lineTo(w * tileSize, canvas.height)
            ctx.stroke()
        }

        for (let h = 0; h < canvas.height / tileSize; h++) {
            ctx.beginPath()
            ctx.moveTo(0, h * tileSize)
            ctx.lineTo(canvas.width, h * tileSize)
            ctx.stroke()
        }
    }

    if (devMode) {
        ctx.font = '30px arial'
        ctx.fillStyle = 'white'
        ctx.fillText(areaIndex, 10, 30)

        ctx.fillStyle = stringColors[colorIndex]
        ctx.fillRect(canvas.width - 40, 0, 40, 40)
    }
}


function loop() {
    
    window.setInterval(function() {

        if (!player.airborn && player.charge == 0) {
            player.vx = 0

            if (keys.includes('a') || keys.includes('arrowleft') && player.charge == 0) {
                player.airborn = true
                player.move(-4, 0)
                player.vx = -3.5
            }

            if (keys.includes('d') || keys.includes('arrowright') && player.charge == 0) {
                player.airborn = true
                player.move(4, 0)
                player.vx = 3.5
            }
        }


        if (keys.includes('j')) {
            player.move(-1, 0)
        }
        if (keys.includes('l')) {
            player.move(1, 0)
        }
        if (keys.includes('k')) {
            player.move(0, 1)
        }
        if (keys.includes('i')) {
            player.move(0, -1)
        }


        // if (player.slipping) {
        //     player.vx -= 0.3
        // }

        if (player.airborn) {
            player.fall()
        }

        if (keys.includes(' ') && !player.airborn) {
            player.chargeJump()
        }


        if (player.y > 600) {
            player.y -= 600
            areaIndex -= 1
        }
        
        if (player.y < 0) {
            player.y += 600
            areaIndex += 1
        }
        
        // console.log(player.vx, player.airborn)

        drawWindow();
        
        // window.requestAnimationFrame(loop);

    }, 1000 / 60);

}
  
loop()

// window.requestAnimationFrame(loop);